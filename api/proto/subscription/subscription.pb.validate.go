// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: subscription.proto

package subscription

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _subscription_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on PlansLite with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlansLite) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlansLite with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlansLiteMultiError, or nil
// if none found.
func (m *PlansLite) ValidateAll() error {
	return m.validate(true)
}

func (m *PlansLite) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetPlans() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PlansLiteValidationError{
						field:  fmt.Sprintf("Plans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PlansLiteValidationError{
						field:  fmt.Sprintf("Plans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PlansLiteValidationError{
					field:  fmt.Sprintf("Plans[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PlansLiteMultiError(errors)
	}

	return nil
}

// PlansLiteMultiError is an error wrapping multiple validation errors returned
// by PlansLite.ValidateAll() if the designated constraints aren't met.
type PlansLiteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlansLiteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlansLiteMultiError) AllErrors() []error { return m }

// PlansLiteValidationError is the validation error returned by
// PlansLite.Validate if the designated constraints aren't met.
type PlansLiteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlansLiteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlansLiteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlansLiteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlansLiteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlansLiteValidationError) ErrorName() string { return "PlansLiteValidationError" }

// Error satisfies the builtin error interface
func (e PlansLiteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlansLite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlansLiteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlansLiteValidationError{}

// Validate checks the field values on ListSubscriptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListSubscriptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSubscriptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSubscriptionsMultiError, or nil if none found.
func (m *ListSubscriptions) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSubscriptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListSubscriptionsMultiError(errors)
	}

	return nil
}

// ListSubscriptionsMultiError is an error wrapping multiple validation errors
// returned by ListSubscriptions.ValidateAll() if the designated constraints
// aren't met.
type ListSubscriptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubscriptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubscriptionsMultiError) AllErrors() []error { return m }

// ListSubscriptionsValidationError is the validation error returned by
// ListSubscriptions.Validate if the designated constraints aren't met.
type ListSubscriptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubscriptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubscriptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubscriptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubscriptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubscriptionsValidationError) ErrorName() string {
	return "ListSubscriptionsValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubscriptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubscriptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubscriptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubscriptionsValidationError{}

// Validate checks the field values on Subscription with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subscription with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubscriptionMultiError, or
// nil if none found.
func (m *Subscription) ValidateAll() error {
	return m.validate(true)
}

func (m *Subscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SubscriptionMultiError(errors)
	}

	return nil
}

// SubscriptionMultiError is an error wrapping multiple validation errors
// returned by Subscription.ValidateAll() if the designated constraints aren't met.
type SubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionMultiError) AllErrors() []error { return m }

// SubscriptionValidationError is the validation error returned by
// Subscription.Validate if the designated constraints aren't met.
type SubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionValidationError) ErrorName() string { return "SubscriptionValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionValidationError{}

// Validate checks the field values on AddSubscription with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddSubscriptionMultiError, or nil if none found.
func (m *AddSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *AddSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AddSubscriptionMultiError(errors)
	}

	return nil
}

// AddSubscriptionMultiError is an error wrapping multiple validation errors
// returned by AddSubscription.ValidateAll() if the designated constraints
// aren't met.
type AddSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddSubscriptionMultiError) AllErrors() []error { return m }

// AddSubscriptionValidationError is the validation error returned by
// AddSubscription.Validate if the designated constraints aren't met.
type AddSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddSubscriptionValidationError) ErrorName() string { return "AddSubscriptionValidationError" }

// Error satisfies the builtin error interface
func (e AddSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddSubscriptionValidationError{}

// Validate checks the field values on UpdateSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubscriptionMultiError, or nil if none found.
func (m *UpdateSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateSubscriptionMultiError(errors)
	}

	return nil
}

// UpdateSubscriptionMultiError is an error wrapping multiple validation errors
// returned by UpdateSubscription.ValidateAll() if the designated constraints
// aren't met.
type UpdateSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubscriptionMultiError) AllErrors() []error { return m }

// UpdateSubscriptionValidationError is the validation error returned by
// UpdateSubscription.Validate if the designated constraints aren't met.
type UpdateSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubscriptionValidationError) ErrorName() string {
	return "UpdateSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubscriptionValidationError{}

// Validate checks the field values on DeleteSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSubscriptionMultiError, or nil if none found.
func (m *DeleteSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteSubscriptionMultiError(errors)
	}

	return nil
}

// DeleteSubscriptionMultiError is an error wrapping multiple validation errors
// returned by DeleteSubscription.ValidateAll() if the designated constraints
// aren't met.
type DeleteSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSubscriptionMultiError) AllErrors() []error { return m }

// DeleteSubscriptionValidationError is the validation error returned by
// DeleteSubscription.Validate if the designated constraints aren't met.
type DeleteSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSubscriptionValidationError) ErrorName() string {
	return "DeleteSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSubscriptionValidationError{}

// Validate checks the field values on ListPlans with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPlans) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlans with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPlansMultiError, or nil
// if none found.
func (m *ListPlans) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlans) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListPlansMultiError(errors)
	}

	return nil
}

// ListPlansMultiError is an error wrapping multiple validation errors returned
// by ListPlans.ValidateAll() if the designated constraints aren't met.
type ListPlansMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlansMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlansMultiError) AllErrors() []error { return m }

// ListPlansValidationError is the validation error returned by
// ListPlans.Validate if the designated constraints aren't met.
type ListPlansValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlansValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlansValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlansValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlansValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlansValidationError) ErrorName() string { return "ListPlansValidationError" }

// Error satisfies the builtin error interface
func (e ListPlansValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlans.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlansValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlansValidationError{}

// Validate checks the field values on Plan with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Plan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plan with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PlanMultiError, or nil if none found.
func (m *Plan) ValidateAll() error {
	return m.validate(true)
}

func (m *Plan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PlanMultiError(errors)
	}

	return nil
}

// PlanMultiError is an error wrapping multiple validation errors returned by
// Plan.ValidateAll() if the designated constraints aren't met.
type PlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlanMultiError) AllErrors() []error { return m }

// PlanValidationError is the validation error returned by Plan.Validate if the
// designated constraints aren't met.
type PlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlanValidationError) ErrorName() string { return "PlanValidationError" }

// Error satisfies the builtin error interface
func (e PlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlanValidationError{}

// Validate checks the field values on UpdatePlan with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdatePlan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePlan with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdatePlanMultiError, or
// nil if none found.
func (m *UpdatePlan) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePlan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdatePlanMultiError(errors)
	}

	return nil
}

// UpdatePlanMultiError is an error wrapping multiple validation errors
// returned by UpdatePlan.ValidateAll() if the designated constraints aren't met.
type UpdatePlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePlanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePlanMultiError) AllErrors() []error { return m }

// UpdatePlanValidationError is the validation error returned by
// UpdatePlan.Validate if the designated constraints aren't met.
type UpdatePlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePlanValidationError) ErrorName() string { return "UpdatePlanValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePlanValidationError{}

// Validate checks the field values on ListCustomers with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListCustomers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCustomers with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListCustomersMultiError, or
// nil if none found.
func (m *ListCustomers) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCustomers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListCustomersMultiError(errors)
	}

	return nil
}

// ListCustomersMultiError is an error wrapping multiple validation errors
// returned by ListCustomers.ValidateAll() if the designated constraints
// aren't met.
type ListCustomersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCustomersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCustomersMultiError) AllErrors() []error { return m }

// ListCustomersValidationError is the validation error returned by
// ListCustomers.Validate if the designated constraints aren't met.
type ListCustomersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCustomersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCustomersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCustomersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCustomersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCustomersValidationError) ErrorName() string { return "ListCustomersValidationError" }

// Error satisfies the builtin error interface
func (e ListCustomersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCustomers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCustomersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCustomersValidationError{}

// Validate checks the field values on Customer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Customer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Customer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CustomerMultiError, or nil
// if none found.
func (m *Customer) ValidateAll() error {
	return m.validate(true)
}

func (m *Customer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CustomerMultiError(errors)
	}

	return nil
}

// CustomerMultiError is an error wrapping multiple validation errors returned
// by Customer.ValidateAll() if the designated constraints aren't met.
type CustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomerMultiError) AllErrors() []error { return m }

// CustomerValidationError is the validation error returned by
// Customer.Validate if the designated constraints aren't met.
type CustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomerValidationError) ErrorName() string { return "CustomerValidationError" }

// Error satisfies the builtin error interface
func (e CustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomerValidationError{}

// Validate checks the field values on AddCustomer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddCustomer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCustomer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddCustomerMultiError, or
// nil if none found.
func (m *AddCustomer) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCustomer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AddCustomerMultiError(errors)
	}

	return nil
}

// AddCustomerMultiError is an error wrapping multiple validation errors
// returned by AddCustomer.ValidateAll() if the designated constraints aren't met.
type AddCustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCustomerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCustomerMultiError) AllErrors() []error { return m }

// AddCustomerValidationError is the validation error returned by
// AddCustomer.Validate if the designated constraints aren't met.
type AddCustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCustomerValidationError) ErrorName() string { return "AddCustomerValidationError" }

// Error satisfies the builtin error interface
func (e AddCustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCustomerValidationError{}

// Validate checks the field values on UpdateCustomer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateCustomer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCustomer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateCustomerMultiError,
// or nil if none found.
func (m *UpdateCustomer) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCustomer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateCustomerMultiError(errors)
	}

	return nil
}

// UpdateCustomerMultiError is an error wrapping multiple validation errors
// returned by UpdateCustomer.ValidateAll() if the designated constraints
// aren't met.
type UpdateCustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCustomerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCustomerMultiError) AllErrors() []error { return m }

// UpdateCustomerValidationError is the validation error returned by
// UpdateCustomer.Validate if the designated constraints aren't met.
type UpdateCustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCustomerValidationError) ErrorName() string { return "UpdateCustomerValidationError" }

// Error satisfies the builtin error interface
func (e UpdateCustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCustomerValidationError{}

// Validate checks the field values on DeleteCustomer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteCustomer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCustomer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteCustomerMultiError,
// or nil if none found.
func (m *DeleteCustomer) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCustomer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteCustomerMultiError(errors)
	}

	return nil
}

// DeleteCustomerMultiError is an error wrapping multiple validation errors
// returned by DeleteCustomer.ValidateAll() if the designated constraints
// aren't met.
type DeleteCustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCustomerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCustomerMultiError) AllErrors() []error { return m }

// DeleteCustomerValidationError is the validation error returned by
// DeleteCustomer.Validate if the designated constraints aren't met.
type DeleteCustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCustomerValidationError) ErrorName() string { return "DeleteCustomerValidationError" }

// Error satisfies the builtin error interface
func (e DeleteCustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCustomerValidationError{}

// Validate checks the field values on Changes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Changes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Changes with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChangesMultiError, or nil if none found.
func (m *Changes) ValidateAll() error {
	return m.validate(true)
}

func (m *Changes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ChangesMultiError(errors)
	}

	return nil
}

// ChangesMultiError is an error wrapping multiple validation errors returned
// by Changes.ValidateAll() if the designated constraints aren't met.
type ChangesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangesMultiError) AllErrors() []error { return m }

// ChangesValidationError is the validation error returned by Changes.Validate
// if the designated constraints aren't met.
type ChangesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangesValidationError) ErrorName() string { return "ChangesValidationError" }

// Error satisfies the builtin error interface
func (e ChangesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChanges.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangesValidationError{}

// Validate checks the field values on Invoices with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Invoices) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoices with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoicesMultiError, or nil
// if none found.
func (m *Invoices) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoices) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return InvoicesMultiError(errors)
	}

	return nil
}

// InvoicesMultiError is an error wrapping multiple validation errors returned
// by Invoices.ValidateAll() if the designated constraints aren't met.
type InvoicesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoicesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoicesMultiError) AllErrors() []error { return m }

// InvoicesValidationError is the validation error returned by
// Invoices.Validate if the designated constraints aren't met.
type InvoicesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoicesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoicesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoicesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoicesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoicesValidationError) ErrorName() string { return "InvoicesValidationError" }

// Error satisfies the builtin error interface
func (e InvoicesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoices.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoicesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoicesValidationError{}

// Validate checks the field values on PlansLite_PlanLite with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PlansLite_PlanLite) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlansLite_PlanLite with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PlansLite_PlanLiteMultiError, or nil if none found.
func (m *PlansLite_PlanLite) ValidateAll() error {
	return m.validate(true)
}

func (m *PlansLite_PlanLite) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlanId

	// no validation rules for Cost

	// no validation rules for Period

	// no validation rules for Title

	// no validation rules for Image

	// no validation rules for TrialPeriod

	// no validation rules for LimitsServers

	// no validation rules for LimitsUsers

	// no validation rules for LimitsCompanies

	// no validation rules for LimitsConnections

	if len(errors) > 0 {
		return PlansLite_PlanLiteMultiError(errors)
	}

	return nil
}

// PlansLite_PlanLiteMultiError is an error wrapping multiple validation errors
// returned by PlansLite_PlanLite.ValidateAll() if the designated constraints
// aren't met.
type PlansLite_PlanLiteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlansLite_PlanLiteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlansLite_PlanLiteMultiError) AllErrors() []error { return m }

// PlansLite_PlanLiteValidationError is the validation error returned by
// PlansLite_PlanLite.Validate if the designated constraints aren't met.
type PlansLite_PlanLiteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlansLite_PlanLiteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlansLite_PlanLiteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlansLite_PlanLiteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlansLite_PlanLiteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlansLite_PlanLiteValidationError) ErrorName() string {
	return "PlansLite_PlanLiteValidationError"
}

// Error satisfies the builtin error interface
func (e PlansLite_PlanLiteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlansLite_PlanLite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlansLite_PlanLiteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlansLite_PlanLiteValidationError{}

// Validate checks the field values on ListSubscriptions_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSubscriptions_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSubscriptions_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSubscriptions_RequestMultiError, or nil if none found.
func (m *ListSubscriptions_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSubscriptions_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Offset

	// no validation rules for SortBy

	// no validation rules for Query

	if m.GetUserId() != "" {

		if err := m._validateUuid(m.GetUserId()); err != nil {
			err = ListSubscriptions_RequestValidationError{
				field:  "UserId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ListSubscriptions_RequestMultiError(errors)
	}

	return nil
}

func (m *ListSubscriptions_Request) _validateUuid(uuid string) error {
	if matched := _subscription_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ListSubscriptions_RequestMultiError is an error wrapping multiple validation
// errors returned by ListSubscriptions_Request.ValidateAll() if the
// designated constraints aren't met.
type ListSubscriptions_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubscriptions_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubscriptions_RequestMultiError) AllErrors() []error { return m }

// ListSubscriptions_RequestValidationError is the validation error returned by
// ListSubscriptions_Request.Validate if the designated constraints aren't met.
type ListSubscriptions_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubscriptions_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubscriptions_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubscriptions_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubscriptions_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubscriptions_RequestValidationError) ErrorName() string {
	return "ListSubscriptions_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubscriptions_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubscriptions_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubscriptions_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubscriptions_RequestValidationError{}

// Validate checks the field values on ListSubscriptions_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSubscriptions_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSubscriptions_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSubscriptions_ResponseMultiError, or nil if none found.
func (m *ListSubscriptions_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSubscriptions_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSubscriptions_ResponseValidationError{
						field:  fmt.Sprintf("Subscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSubscriptions_ResponseValidationError{
						field:  fmt.Sprintf("Subscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSubscriptions_ResponseValidationError{
					field:  fmt.Sprintf("Subscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListSubscriptions_ResponseMultiError(errors)
	}

	return nil
}

// ListSubscriptions_ResponseMultiError is an error wrapping multiple
// validation errors returned by ListSubscriptions_Response.ValidateAll() if
// the designated constraints aren't met.
type ListSubscriptions_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubscriptions_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubscriptions_ResponseMultiError) AllErrors() []error { return m }

// ListSubscriptions_ResponseValidationError is the validation error returned
// by ListSubscriptions_Response.Validate if the designated constraints aren't met.
type ListSubscriptions_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubscriptions_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubscriptions_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubscriptions_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubscriptions_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubscriptions_ResponseValidationError) ErrorName() string {
	return "ListSubscriptions_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubscriptions_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubscriptions_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubscriptions_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubscriptions_ResponseValidationError{}

// Validate checks the field values on Subscription_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Subscription_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subscription_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Subscription_RequestMultiError, or nil if none found.
func (m *Subscription_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *Subscription_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionId

	if len(errors) > 0 {
		return Subscription_RequestMultiError(errors)
	}

	return nil
}

// Subscription_RequestMultiError is an error wrapping multiple validation
// errors returned by Subscription_Request.ValidateAll() if the designated
// constraints aren't met.
type Subscription_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Subscription_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Subscription_RequestMultiError) AllErrors() []error { return m }

// Subscription_RequestValidationError is the validation error returned by
// Subscription_Request.Validate if the designated constraints aren't met.
type Subscription_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Subscription_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Subscription_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Subscription_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Subscription_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Subscription_RequestValidationError) ErrorName() string {
	return "Subscription_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e Subscription_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscription_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Subscription_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Subscription_RequestValidationError{}

// Validate checks the field values on Subscription_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Subscription_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subscription_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Subscription_ResponseMultiError, or nil if none found.
func (m *Subscription_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *Subscription_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionId

	// no validation rules for CustomerId

	// no validation rules for CustomerName

	// no validation rules for PlanId

	// no validation rules for PlanName

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Subscription_ResponseValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Subscription_ResponseValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Subscription_ResponseValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Subscription_ResponseValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Subscription_ResponseValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Subscription_ResponseValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for StripeId

	if len(errors) > 0 {
		return Subscription_ResponseMultiError(errors)
	}

	return nil
}

// Subscription_ResponseMultiError is an error wrapping multiple validation
// errors returned by Subscription_Response.ValidateAll() if the designated
// constraints aren't met.
type Subscription_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Subscription_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Subscription_ResponseMultiError) AllErrors() []error { return m }

// Subscription_ResponseValidationError is the validation error returned by
// Subscription_Response.Validate if the designated constraints aren't met.
type Subscription_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Subscription_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Subscription_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Subscription_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Subscription_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Subscription_ResponseValidationError) ErrorName() string {
	return "Subscription_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e Subscription_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscription_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Subscription_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Subscription_ResponseValidationError{}

// Validate checks the field values on AddSubscription_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddSubscription_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddSubscription_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddSubscription_RequestMultiError, or nil if none found.
func (m *AddSubscription_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *AddSubscription_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionId

	// no validation rules for CustomerId

	// no validation rules for CustomerName

	// no validation rules for PlanId

	// no validation rules for PlanName

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddSubscription_RequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddSubscription_RequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddSubscription_RequestValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddSubscription_RequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddSubscription_RequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddSubscription_RequestValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for StripeId

	if len(errors) > 0 {
		return AddSubscription_RequestMultiError(errors)
	}

	return nil
}

// AddSubscription_RequestMultiError is an error wrapping multiple validation
// errors returned by AddSubscription_Request.ValidateAll() if the designated
// constraints aren't met.
type AddSubscription_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddSubscription_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddSubscription_RequestMultiError) AllErrors() []error { return m }

// AddSubscription_RequestValidationError is the validation error returned by
// AddSubscription_Request.Validate if the designated constraints aren't met.
type AddSubscription_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddSubscription_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddSubscription_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddSubscription_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddSubscription_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddSubscription_RequestValidationError) ErrorName() string {
	return "AddSubscription_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddSubscription_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddSubscription_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddSubscription_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddSubscription_RequestValidationError{}

// Validate checks the field values on AddSubscription_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddSubscription_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddSubscription_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddSubscription_ResponseMultiError, or nil if none found.
func (m *AddSubscription_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *AddSubscription_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionId

	if len(errors) > 0 {
		return AddSubscription_ResponseMultiError(errors)
	}

	return nil
}

// AddSubscription_ResponseMultiError is an error wrapping multiple validation
// errors returned by AddSubscription_Response.ValidateAll() if the designated
// constraints aren't met.
type AddSubscription_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddSubscription_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddSubscription_ResponseMultiError) AllErrors() []error { return m }

// AddSubscription_ResponseValidationError is the validation error returned by
// AddSubscription_Response.Validate if the designated constraints aren't met.
type AddSubscription_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddSubscription_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddSubscription_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddSubscription_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddSubscription_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddSubscription_ResponseValidationError) ErrorName() string {
	return "AddSubscription_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddSubscription_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddSubscription_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddSubscription_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddSubscription_ResponseValidationError{}

// Validate checks the field values on UpdateSubscription_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubscription_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubscription_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubscription_RequestMultiError, or nil if none found.
func (m *UpdateSubscription_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubscription_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubscriptionId() != "" {

		if err := m._validateUuid(m.GetSubscriptionId()); err != nil {
			err = UpdateSubscription_RequestValidationError{
				field:  "SubscriptionId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for CustomerId

	// no validation rules for CustomerName

	// no validation rules for PlanId

	// no validation rules for PlanName

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSubscription_RequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSubscription_RequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSubscription_RequestValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSubscription_RequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSubscription_RequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSubscription_RequestValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for StripeId

	if len(errors) > 0 {
		return UpdateSubscription_RequestMultiError(errors)
	}

	return nil
}

func (m *UpdateSubscription_Request) _validateUuid(uuid string) error {
	if matched := _subscription_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UpdateSubscription_RequestMultiError is an error wrapping multiple
// validation errors returned by UpdateSubscription_Request.ValidateAll() if
// the designated constraints aren't met.
type UpdateSubscription_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubscription_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubscription_RequestMultiError) AllErrors() []error { return m }

// UpdateSubscription_RequestValidationError is the validation error returned
// by UpdateSubscription_Request.Validate if the designated constraints aren't met.
type UpdateSubscription_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubscription_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubscription_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubscription_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubscription_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubscription_RequestValidationError) ErrorName() string {
	return "UpdateSubscription_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubscription_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubscription_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubscription_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubscription_RequestValidationError{}

// Validate checks the field values on UpdateSubscription_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubscription_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubscription_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubscription_ResponseMultiError, or nil if none found.
func (m *UpdateSubscription_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubscription_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateSubscription_ResponseMultiError(errors)
	}

	return nil
}

// UpdateSubscription_ResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateSubscription_Response.ValidateAll() if
// the designated constraints aren't met.
type UpdateSubscription_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubscription_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubscription_ResponseMultiError) AllErrors() []error { return m }

// UpdateSubscription_ResponseValidationError is the validation error returned
// by UpdateSubscription_Response.Validate if the designated constraints
// aren't met.
type UpdateSubscription_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubscription_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubscription_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubscription_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubscription_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubscription_ResponseValidationError) ErrorName() string {
	return "UpdateSubscription_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubscription_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubscription_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubscription_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubscription_ResponseValidationError{}

// Validate checks the field values on DeleteSubscription_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSubscription_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSubscription_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSubscription_RequestMultiError, or nil if none found.
func (m *DeleteSubscription_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSubscription_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubscriptionId() != "" {

		if err := m._validateUuid(m.GetSubscriptionId()); err != nil {
			err = DeleteSubscription_RequestValidationError{
				field:  "SubscriptionId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return DeleteSubscription_RequestMultiError(errors)
	}

	return nil
}

func (m *DeleteSubscription_Request) _validateUuid(uuid string) error {
	if matched := _subscription_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DeleteSubscription_RequestMultiError is an error wrapping multiple
// validation errors returned by DeleteSubscription_Request.ValidateAll() if
// the designated constraints aren't met.
type DeleteSubscription_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSubscription_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSubscription_RequestMultiError) AllErrors() []error { return m }

// DeleteSubscription_RequestValidationError is the validation error returned
// by DeleteSubscription_Request.Validate if the designated constraints aren't met.
type DeleteSubscription_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSubscription_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSubscription_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSubscription_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSubscription_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSubscription_RequestValidationError) ErrorName() string {
	return "DeleteSubscription_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSubscription_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSubscription_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSubscription_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSubscription_RequestValidationError{}

// Validate checks the field values on DeleteSubscription_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSubscription_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSubscription_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSubscription_ResponseMultiError, or nil if none found.
func (m *DeleteSubscription_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSubscription_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteSubscription_ResponseMultiError(errors)
	}

	return nil
}

// DeleteSubscription_ResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteSubscription_Response.ValidateAll() if
// the designated constraints aren't met.
type DeleteSubscription_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSubscription_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSubscription_ResponseMultiError) AllErrors() []error { return m }

// DeleteSubscription_ResponseValidationError is the validation error returned
// by DeleteSubscription_Response.Validate if the designated constraints
// aren't met.
type DeleteSubscription_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSubscription_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSubscription_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSubscription_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSubscription_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSubscription_ResponseValidationError) ErrorName() string {
	return "DeleteSubscription_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSubscription_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSubscription_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSubscription_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSubscription_ResponseValidationError{}

// Validate checks the field values on ListPlans_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPlans_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlans_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlans_RequestMultiError, or nil if none found.
func (m *ListPlans_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlans_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Offset

	// no validation rules for SortBy

	// no validation rules for Query

	if m.GetUserId() != "" {

		if err := m._validateUuid(m.GetUserId()); err != nil {
			err = ListPlans_RequestValidationError{
				field:  "UserId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ListPlans_RequestMultiError(errors)
	}

	return nil
}

func (m *ListPlans_Request) _validateUuid(uuid string) error {
	if matched := _subscription_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ListPlans_RequestMultiError is an error wrapping multiple validation errors
// returned by ListPlans_Request.ValidateAll() if the designated constraints
// aren't met.
type ListPlans_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlans_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlans_RequestMultiError) AllErrors() []error { return m }

// ListPlans_RequestValidationError is the validation error returned by
// ListPlans_Request.Validate if the designated constraints aren't met.
type ListPlans_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlans_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlans_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlans_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlans_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlans_RequestValidationError) ErrorName() string {
	return "ListPlans_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlans_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlans_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlans_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlans_RequestValidationError{}

// Validate checks the field values on ListPlans_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlans_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlans_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlans_ResponseMultiError, or nil if none found.
func (m *ListPlans_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlans_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetPlans() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPlans_ResponseValidationError{
						field:  fmt.Sprintf("Plans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPlans_ResponseValidationError{
						field:  fmt.Sprintf("Plans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPlans_ResponseValidationError{
					field:  fmt.Sprintf("Plans[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPlans_ResponseMultiError(errors)
	}

	return nil
}

// ListPlans_ResponseMultiError is an error wrapping multiple validation errors
// returned by ListPlans_Response.ValidateAll() if the designated constraints
// aren't met.
type ListPlans_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlans_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlans_ResponseMultiError) AllErrors() []error { return m }

// ListPlans_ResponseValidationError is the validation error returned by
// ListPlans_Response.Validate if the designated constraints aren't met.
type ListPlans_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlans_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlans_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlans_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlans_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlans_ResponseValidationError) ErrorName() string {
	return "ListPlans_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlans_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlans_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlans_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlans_ResponseValidationError{}

// Validate checks the field values on ListPlans_Response_PlanInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlans_Response_PlanInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlans_Response_PlanInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlans_Response_PlanInfoMultiError, or nil if none found.
func (m *ListPlans_Response_PlanInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlans_Response_PlanInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionCount

	if all {
		switch v := interface{}(m.GetPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPlans_Response_PlanInfoValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPlans_Response_PlanInfoValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPlans_Response_PlanInfoValidationError{
				field:  "Plan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListPlans_Response_PlanInfoMultiError(errors)
	}

	return nil
}

// ListPlans_Response_PlanInfoMultiError is an error wrapping multiple
// validation errors returned by ListPlans_Response_PlanInfo.ValidateAll() if
// the designated constraints aren't met.
type ListPlans_Response_PlanInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlans_Response_PlanInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlans_Response_PlanInfoMultiError) AllErrors() []error { return m }

// ListPlans_Response_PlanInfoValidationError is the validation error returned
// by ListPlans_Response_PlanInfo.Validate if the designated constraints
// aren't met.
type ListPlans_Response_PlanInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlans_Response_PlanInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlans_Response_PlanInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlans_Response_PlanInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlans_Response_PlanInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlans_Response_PlanInfoValidationError) ErrorName() string {
	return "ListPlans_Response_PlanInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlans_Response_PlanInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlans_Response_PlanInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlans_Response_PlanInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlans_Response_PlanInfoValidationError{}

// Validate checks the field values on Plan_Request with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plan_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plan_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plan_RequestMultiError, or
// nil if none found.
func (m *Plan_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *Plan_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPlanId() != "" {

		if err := m._validateUuid(m.GetPlanId()); err != nil {
			err = Plan_RequestValidationError{
				field:  "PlanId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return Plan_RequestMultiError(errors)
	}

	return nil
}

func (m *Plan_Request) _validateUuid(uuid string) error {
	if matched := _subscription_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// Plan_RequestMultiError is an error wrapping multiple validation errors
// returned by Plan_Request.ValidateAll() if the designated constraints aren't met.
type Plan_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plan_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plan_RequestMultiError) AllErrors() []error { return m }

// Plan_RequestValidationError is the validation error returned by
// Plan_Request.Validate if the designated constraints aren't met.
type Plan_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plan_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plan_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plan_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plan_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plan_RequestValidationError) ErrorName() string { return "Plan_RequestValidationError" }

// Error satisfies the builtin error interface
func (e Plan_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlan_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plan_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plan_RequestValidationError{}

// Validate checks the field values on Plan_Response with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plan_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plan_Response with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plan_ResponseMultiError, or
// nil if none found.
func (m *Plan_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *Plan_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlanId

	// no validation rules for Cost

	// no validation rules for Period

	// no validation rules for Title

	// no validation rules for StripeId

	// no validation rules for Benefits

	// no validation rules for Image

	// no validation rules for Active

	// no validation rules for Trial

	// no validation rules for TrialPeriod

	// no validation rules for LimitsServers

	// no validation rules for LimitsUsers

	// no validation rules for LimitsCompanies

	// no validation rules for LimitsConnections

	// no validation rules for Default

	if len(errors) > 0 {
		return Plan_ResponseMultiError(errors)
	}

	return nil
}

// Plan_ResponseMultiError is an error wrapping multiple validation errors
// returned by Plan_Response.ValidateAll() if the designated constraints
// aren't met.
type Plan_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plan_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plan_ResponseMultiError) AllErrors() []error { return m }

// Plan_ResponseValidationError is the validation error returned by
// Plan_Response.Validate if the designated constraints aren't met.
type Plan_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plan_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plan_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plan_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plan_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plan_ResponseValidationError) ErrorName() string { return "Plan_ResponseValidationError" }

// Error satisfies the builtin error interface
func (e Plan_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlan_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plan_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plan_ResponseValidationError{}

// Validate checks the field values on UpdatePlan_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePlan_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePlan_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePlan_RequestMultiError, or nil if none found.
func (m *UpdatePlan_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePlan_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPlanId() != "" {

		if err := m._validateUuid(m.GetPlanId()); err != nil {
			err = UpdatePlan_RequestValidationError{
				field:  "PlanId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Cost

	// no validation rules for Period

	// no validation rules for Title

	// no validation rules for StripeId

	// no validation rules for Benefits

	// no validation rules for Image

	// no validation rules for Active

	// no validation rules for Trial

	// no validation rules for TrialPeriod

	// no validation rules for LimitsServers

	// no validation rules for LimitsUsers

	// no validation rules for LimitsCompanies

	// no validation rules for LimitsConnections

	// no validation rules for Default

	if len(errors) > 0 {
		return UpdatePlan_RequestMultiError(errors)
	}

	return nil
}

func (m *UpdatePlan_Request) _validateUuid(uuid string) error {
	if matched := _subscription_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UpdatePlan_RequestMultiError is an error wrapping multiple validation errors
// returned by UpdatePlan_Request.ValidateAll() if the designated constraints
// aren't met.
type UpdatePlan_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePlan_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePlan_RequestMultiError) AllErrors() []error { return m }

// UpdatePlan_RequestValidationError is the validation error returned by
// UpdatePlan_Request.Validate if the designated constraints aren't met.
type UpdatePlan_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePlan_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePlan_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePlan_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePlan_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePlan_RequestValidationError) ErrorName() string {
	return "UpdatePlan_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePlan_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePlan_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePlan_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePlan_RequestValidationError{}

// Validate checks the field values on UpdatePlan_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePlan_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePlan_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePlan_ResponseMultiError, or nil if none found.
func (m *UpdatePlan_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePlan_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdatePlan_ResponseMultiError(errors)
	}

	return nil
}

// UpdatePlan_ResponseMultiError is an error wrapping multiple validation
// errors returned by UpdatePlan_Response.ValidateAll() if the designated
// constraints aren't met.
type UpdatePlan_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePlan_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePlan_ResponseMultiError) AllErrors() []error { return m }

// UpdatePlan_ResponseValidationError is the validation error returned by
// UpdatePlan_Response.Validate if the designated constraints aren't met.
type UpdatePlan_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePlan_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePlan_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePlan_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePlan_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePlan_ResponseValidationError) ErrorName() string {
	return "UpdatePlan_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePlan_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePlan_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePlan_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePlan_ResponseValidationError{}

// Validate checks the field values on ListCustomers_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCustomers_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCustomers_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCustomers_RequestMultiError, or nil if none found.
func (m *ListCustomers_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCustomers_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Offset

	// no validation rules for SortBy

	if len(errors) > 0 {
		return ListCustomers_RequestMultiError(errors)
	}

	return nil
}

// ListCustomers_RequestMultiError is an error wrapping multiple validation
// errors returned by ListCustomers_Request.ValidateAll() if the designated
// constraints aren't met.
type ListCustomers_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCustomers_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCustomers_RequestMultiError) AllErrors() []error { return m }

// ListCustomers_RequestValidationError is the validation error returned by
// ListCustomers_Request.Validate if the designated constraints aren't met.
type ListCustomers_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCustomers_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCustomers_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCustomers_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCustomers_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCustomers_RequestValidationError) ErrorName() string {
	return "ListCustomers_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCustomers_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCustomers_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCustomers_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCustomers_RequestValidationError{}

// Validate checks the field values on ListCustomers_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCustomers_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCustomers_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCustomers_ResponseMultiError, or nil if none found.
func (m *ListCustomers_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCustomers_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetCustomers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCustomers_ResponseValidationError{
						field:  fmt.Sprintf("Customers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCustomers_ResponseValidationError{
						field:  fmt.Sprintf("Customers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCustomers_ResponseValidationError{
					field:  fmt.Sprintf("Customers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCustomers_ResponseMultiError(errors)
	}

	return nil
}

// ListCustomers_ResponseMultiError is an error wrapping multiple validation
// errors returned by ListCustomers_Response.ValidateAll() if the designated
// constraints aren't met.
type ListCustomers_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCustomers_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCustomers_ResponseMultiError) AllErrors() []error { return m }

// ListCustomers_ResponseValidationError is the validation error returned by
// ListCustomers_Response.Validate if the designated constraints aren't met.
type ListCustomers_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCustomers_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCustomers_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCustomers_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCustomers_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCustomers_ResponseValidationError) ErrorName() string {
	return "ListCustomers_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCustomers_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCustomers_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCustomers_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCustomers_ResponseValidationError{}

// Validate checks the field values on Customer_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Customer_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Customer_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Customer_RequestMultiError, or nil if none found.
func (m *Customer_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *Customer_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() != "" {

		if err := m._validateUuid(m.GetUserId()); err != nil {
			err = Customer_RequestValidationError{
				field:  "UserId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return Customer_RequestMultiError(errors)
	}

	return nil
}

func (m *Customer_Request) _validateUuid(uuid string) error {
	if matched := _subscription_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// Customer_RequestMultiError is an error wrapping multiple validation errors
// returned by Customer_Request.ValidateAll() if the designated constraints
// aren't met.
type Customer_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Customer_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Customer_RequestMultiError) AllErrors() []error { return m }

// Customer_RequestValidationError is the validation error returned by
// Customer_Request.Validate if the designated constraints aren't met.
type Customer_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Customer_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Customer_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Customer_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Customer_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Customer_RequestValidationError) ErrorName() string { return "Customer_RequestValidationError" }

// Error satisfies the builtin error interface
func (e Customer_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomer_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Customer_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Customer_RequestValidationError{}

// Validate checks the field values on Customer_Response with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Customer_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Customer_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Customer_ResponseMultiError, or nil if none found.
func (m *Customer_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *Customer_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for StripeId

	if len(errors) > 0 {
		return Customer_ResponseMultiError(errors)
	}

	return nil
}

// Customer_ResponseMultiError is an error wrapping multiple validation errors
// returned by Customer_Response.ValidateAll() if the designated constraints
// aren't met.
type Customer_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Customer_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Customer_ResponseMultiError) AllErrors() []error { return m }

// Customer_ResponseValidationError is the validation error returned by
// Customer_Response.Validate if the designated constraints aren't met.
type Customer_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Customer_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Customer_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Customer_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Customer_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Customer_ResponseValidationError) ErrorName() string {
	return "Customer_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e Customer_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomer_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Customer_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Customer_ResponseValidationError{}

// Validate checks the field values on AddCustomer_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddCustomer_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCustomer_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddCustomer_RequestMultiError, or nil if none found.
func (m *AddCustomer_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCustomer_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for StripeId

	if len(errors) > 0 {
		return AddCustomer_RequestMultiError(errors)
	}

	return nil
}

// AddCustomer_RequestMultiError is an error wrapping multiple validation
// errors returned by AddCustomer_Request.ValidateAll() if the designated
// constraints aren't met.
type AddCustomer_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCustomer_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCustomer_RequestMultiError) AllErrors() []error { return m }

// AddCustomer_RequestValidationError is the validation error returned by
// AddCustomer_Request.Validate if the designated constraints aren't met.
type AddCustomer_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCustomer_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCustomer_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCustomer_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCustomer_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCustomer_RequestValidationError) ErrorName() string {
	return "AddCustomer_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddCustomer_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCustomer_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCustomer_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCustomer_RequestValidationError{}

// Validate checks the field values on AddCustomer_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddCustomer_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCustomer_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddCustomer_ResponseMultiError, or nil if none found.
func (m *AddCustomer_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCustomer_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CustomerId

	if len(errors) > 0 {
		return AddCustomer_ResponseMultiError(errors)
	}

	return nil
}

// AddCustomer_ResponseMultiError is an error wrapping multiple validation
// errors returned by AddCustomer_Response.ValidateAll() if the designated
// constraints aren't met.
type AddCustomer_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCustomer_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCustomer_ResponseMultiError) AllErrors() []error { return m }

// AddCustomer_ResponseValidationError is the validation error returned by
// AddCustomer_Response.Validate if the designated constraints aren't met.
type AddCustomer_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCustomer_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCustomer_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCustomer_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCustomer_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCustomer_ResponseValidationError) ErrorName() string {
	return "AddCustomer_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddCustomer_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCustomer_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCustomer_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCustomer_ResponseValidationError{}

// Validate checks the field values on UpdateCustomer_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCustomer_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCustomer_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCustomer_RequestMultiError, or nil if none found.
func (m *UpdateCustomer_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCustomer_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for StripeId

	if len(errors) > 0 {
		return UpdateCustomer_RequestMultiError(errors)
	}

	return nil
}

// UpdateCustomer_RequestMultiError is an error wrapping multiple validation
// errors returned by UpdateCustomer_Request.ValidateAll() if the designated
// constraints aren't met.
type UpdateCustomer_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCustomer_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCustomer_RequestMultiError) AllErrors() []error { return m }

// UpdateCustomer_RequestValidationError is the validation error returned by
// UpdateCustomer_Request.Validate if the designated constraints aren't met.
type UpdateCustomer_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCustomer_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCustomer_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCustomer_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCustomer_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCustomer_RequestValidationError) ErrorName() string {
	return "UpdateCustomer_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCustomer_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCustomer_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCustomer_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCustomer_RequestValidationError{}

// Validate checks the field values on UpdateCustomer_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCustomer_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCustomer_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCustomer_ResponseMultiError, or nil if none found.
func (m *UpdateCustomer_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCustomer_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateCustomer_ResponseMultiError(errors)
	}

	return nil
}

// UpdateCustomer_ResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateCustomer_Response.ValidateAll() if the designated
// constraints aren't met.
type UpdateCustomer_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCustomer_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCustomer_ResponseMultiError) AllErrors() []error { return m }

// UpdateCustomer_ResponseValidationError is the validation error returned by
// UpdateCustomer_Response.Validate if the designated constraints aren't met.
type UpdateCustomer_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCustomer_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCustomer_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCustomer_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCustomer_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCustomer_ResponseValidationError) ErrorName() string {
	return "UpdateCustomer_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCustomer_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCustomer_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCustomer_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCustomer_ResponseValidationError{}

// Validate checks the field values on DeleteCustomer_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCustomer_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCustomer_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCustomer_RequestMultiError, or nil if none found.
func (m *DeleteCustomer_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCustomer_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() != "" {

		if err := m._validateUuid(m.GetUserId()); err != nil {
			err = DeleteCustomer_RequestValidationError{
				field:  "UserId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return DeleteCustomer_RequestMultiError(errors)
	}

	return nil
}

func (m *DeleteCustomer_Request) _validateUuid(uuid string) error {
	if matched := _subscription_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DeleteCustomer_RequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCustomer_Request.ValidateAll() if the designated
// constraints aren't met.
type DeleteCustomer_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCustomer_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCustomer_RequestMultiError) AllErrors() []error { return m }

// DeleteCustomer_RequestValidationError is the validation error returned by
// DeleteCustomer_Request.Validate if the designated constraints aren't met.
type DeleteCustomer_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCustomer_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCustomer_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCustomer_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCustomer_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCustomer_RequestValidationError) ErrorName() string {
	return "DeleteCustomer_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCustomer_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCustomer_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCustomer_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCustomer_RequestValidationError{}

// Validate checks the field values on DeleteCustomer_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCustomer_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCustomer_Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCustomer_ResponseMultiError, or nil if none found.
func (m *DeleteCustomer_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCustomer_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteCustomer_ResponseMultiError(errors)
	}

	return nil
}

// DeleteCustomer_ResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCustomer_Response.ValidateAll() if the designated
// constraints aren't met.
type DeleteCustomer_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCustomer_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCustomer_ResponseMultiError) AllErrors() []error { return m }

// DeleteCustomer_ResponseValidationError is the validation error returned by
// DeleteCustomer_Response.Validate if the designated constraints aren't met.
type DeleteCustomer_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCustomer_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCustomer_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCustomer_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCustomer_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCustomer_ResponseValidationError) ErrorName() string {
	return "DeleteCustomer_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCustomer_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCustomer_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCustomer_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCustomer_ResponseValidationError{}

// Validate checks the field values on Changes_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Changes_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Changes_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Changes_RequestMultiError, or nil if none found.
func (m *Changes_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *Changes_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Offset

	// no validation rules for SortBy

	// no validation rules for Query

	if len(errors) > 0 {
		return Changes_RequestMultiError(errors)
	}

	return nil
}

// Changes_RequestMultiError is an error wrapping multiple validation errors
// returned by Changes_Request.ValidateAll() if the designated constraints
// aren't met.
type Changes_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Changes_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Changes_RequestMultiError) AllErrors() []error { return m }

// Changes_RequestValidationError is the validation error returned by
// Changes_Request.Validate if the designated constraints aren't met.
type Changes_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Changes_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Changes_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Changes_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Changes_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Changes_RequestValidationError) ErrorName() string { return "Changes_RequestValidationError" }

// Error satisfies the builtin error interface
func (e Changes_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChanges_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Changes_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Changes_RequestValidationError{}

// Validate checks the field values on Changes_Response with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Changes_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Changes_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Changes_ResponseMultiError, or nil if none found.
func (m *Changes_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *Changes_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetChange() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Changes_ResponseValidationError{
						field:  fmt.Sprintf("Change[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Changes_ResponseValidationError{
						field:  fmt.Sprintf("Change[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Changes_ResponseValidationError{
					field:  fmt.Sprintf("Change[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Changes_ResponseMultiError(errors)
	}

	return nil
}

// Changes_ResponseMultiError is an error wrapping multiple validation errors
// returned by Changes_Response.ValidateAll() if the designated constraints
// aren't met.
type Changes_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Changes_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Changes_ResponseMultiError) AllErrors() []error { return m }

// Changes_ResponseValidationError is the validation error returned by
// Changes_Response.Validate if the designated constraints aren't met.
type Changes_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Changes_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Changes_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Changes_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Changes_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Changes_ResponseValidationError) ErrorName() string { return "Changes_ResponseValidationError" }

// Error satisfies the builtin error interface
func (e Changes_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChanges_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Changes_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Changes_ResponseValidationError{}

// Validate checks the field values on Changes_Response_Change with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Changes_Response_Change) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Changes_Response_Change with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Changes_Response_ChangeMultiError, or nil if none found.
func (m *Changes_Response_Change) ValidateAll() error {
	return m.validate(true)
}

func (m *Changes_Response_Change) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChangeId

	// no validation rules for SubscriptionId

	// no validation rules for PlanId

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Changes_Response_ChangeValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Changes_Response_ChangeValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Changes_Response_ChangeValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Changes_Response_ChangeMultiError(errors)
	}

	return nil
}

// Changes_Response_ChangeMultiError is an error wrapping multiple validation
// errors returned by Changes_Response_Change.ValidateAll() if the designated
// constraints aren't met.
type Changes_Response_ChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Changes_Response_ChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Changes_Response_ChangeMultiError) AllErrors() []error { return m }

// Changes_Response_ChangeValidationError is the validation error returned by
// Changes_Response_Change.Validate if the designated constraints aren't met.
type Changes_Response_ChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Changes_Response_ChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Changes_Response_ChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Changes_Response_ChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Changes_Response_ChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Changes_Response_ChangeValidationError) ErrorName() string {
	return "Changes_Response_ChangeValidationError"
}

// Error satisfies the builtin error interface
func (e Changes_Response_ChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChanges_Response_Change.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Changes_Response_ChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Changes_Response_ChangeValidationError{}

// Validate checks the field values on Invoices_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Invoices_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoices_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Invoices_RequestMultiError, or nil if none found.
func (m *Invoices_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoices_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Offset

	// no validation rules for SortBy

	// no validation rules for Query

	if len(errors) > 0 {
		return Invoices_RequestMultiError(errors)
	}

	return nil
}

// Invoices_RequestMultiError is an error wrapping multiple validation errors
// returned by Invoices_Request.ValidateAll() if the designated constraints
// aren't met.
type Invoices_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Invoices_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Invoices_RequestMultiError) AllErrors() []error { return m }

// Invoices_RequestValidationError is the validation error returned by
// Invoices_Request.Validate if the designated constraints aren't met.
type Invoices_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Invoices_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Invoices_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Invoices_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Invoices_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Invoices_RequestValidationError) ErrorName() string { return "Invoices_RequestValidationError" }

// Error satisfies the builtin error interface
func (e Invoices_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoices_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Invoices_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Invoices_RequestValidationError{}

// Validate checks the field values on Invoices_Response with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Invoices_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoices_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Invoices_ResponseMultiError, or nil if none found.
func (m *Invoices_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoices_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetInvoice() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Invoices_ResponseValidationError{
						field:  fmt.Sprintf("Invoice[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Invoices_ResponseValidationError{
						field:  fmt.Sprintf("Invoice[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Invoices_ResponseValidationError{
					field:  fmt.Sprintf("Invoice[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Invoices_ResponseMultiError(errors)
	}

	return nil
}

// Invoices_ResponseMultiError is an error wrapping multiple validation errors
// returned by Invoices_Response.ValidateAll() if the designated constraints
// aren't met.
type Invoices_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Invoices_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Invoices_ResponseMultiError) AllErrors() []error { return m }

// Invoices_ResponseValidationError is the validation error returned by
// Invoices_Response.Validate if the designated constraints aren't met.
type Invoices_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Invoices_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Invoices_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Invoices_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Invoices_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Invoices_ResponseValidationError) ErrorName() string {
	return "Invoices_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e Invoices_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoices_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Invoices_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Invoices_ResponseValidationError{}

// Validate checks the field values on Invoices_Response_Invoice with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Invoices_Response_Invoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoices_Response_Invoice with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Invoices_Response_InvoiceMultiError, or nil if none found.
func (m *Invoices_Response_Invoice) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoices_Response_Invoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InvoiceId

	// no validation rules for SubscriptionId

	// no validation rules for PlanId

	// no validation rules for StripeId

	// no validation rules for Url

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Invoices_Response_InvoiceValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Invoices_Response_InvoiceValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Invoices_Response_InvoiceValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Amount

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetPeriodStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Invoices_Response_InvoiceValidationError{
					field:  "PeriodStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Invoices_Response_InvoiceValidationError{
					field:  "PeriodStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeriodStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Invoices_Response_InvoiceValidationError{
				field:  "PeriodStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPeriodEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Invoices_Response_InvoiceValidationError{
					field:  "PeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Invoices_Response_InvoiceValidationError{
					field:  "PeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeriodEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Invoices_Response_InvoiceValidationError{
				field:  "PeriodEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Invoices_Response_InvoiceMultiError(errors)
	}

	return nil
}

// Invoices_Response_InvoiceMultiError is an error wrapping multiple validation
// errors returned by Invoices_Response_Invoice.ValidateAll() if the
// designated constraints aren't met.
type Invoices_Response_InvoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Invoices_Response_InvoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Invoices_Response_InvoiceMultiError) AllErrors() []error { return m }

// Invoices_Response_InvoiceValidationError is the validation error returned by
// Invoices_Response_Invoice.Validate if the designated constraints aren't met.
type Invoices_Response_InvoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Invoices_Response_InvoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Invoices_Response_InvoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Invoices_Response_InvoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Invoices_Response_InvoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Invoices_Response_InvoiceValidationError) ErrorName() string {
	return "Invoices_Response_InvoiceValidationError"
}

// Error satisfies the builtin error interface
func (e Invoices_Response_InvoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoices_Response_Invoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Invoices_Response_InvoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Invoices_Response_InvoiceValidationError{}
